{
    "identity": "nprot-615",
    "title": "Expression and network analysis of Illumina microarray data",
    "content": [
        {
            "header": "Introduction",
            "content": "Microarrays are commonly used tools for assessing changes in gene expression between two populations.  Many algorithms exist for analyzing the hybridization signals from theses arrays.  Here, we present our code for assessing changes in expression from samples hybridized to Illumina whole genome microarrays.  We also include our code for building weighted gene coexpression networks.  Finally, we present how we determined the overlap from two independent microarray studies."
        },
        {
            "header": "Equipment",
            "content": "1.  Requires a personal computer running R/Bioconductor."
        },
        {
            "header": "Procedure",
            "content": "1. ###This code is for analyzing the SH-SY5Y data from Illumina Human Ref8-v2 arrays using R\r\n  ###The following abbreviations are used: V= control cells; WT= cells overexpressing human FOXP2; M12= cells overexpressing chimp FOXP2\r\n\n\nLoad packages\r\n\n\nlibrary \\(Biobase)\r\n\n\nlibrary\\(marray)\r\n\n\nlibrary \\(limma)\r\n\n\nlibrary\\(RColorBrewer)\r\n\n\nlibrary\\(MASS)\r\n\n\nlibrary\\(gplots)\r\n\n\n###Read in the dataset\r\n\n\n###samples not included in this paper are excluded\r\n\n\nload\\(\u201cline1367_noM125_justdata.R\u201d)\r\n\n\nmydata<-mydata\\[,-c\\(13:24)] #excluding line3\r\n\n\ndetsco<-detsco\\[,-c\\(13:24)] #excluding line3\r\n\n\nsds<-sds\\[,-c\\(13:24)] #excluding line3\r\n\n\nbeads<-beads\\[,-c\\(13:24)] #excluding line3\r\n\n\nSamples<-Samples\\[-c\\(13:24),] #excluding line3\r\n\n\nmatriz <- as.matrix\\(mydata)\r\n\n\nROWlabels<-as.character\\(paste\\(Samples$Condition, Samples$CellLine, Samples$Replicate, sep=\u201d_\u201d))\r\n\n\nphD <- Samples\\[,c\\(1,3,4,5)]\r\n\n\nrownames\\(phD)<-ROWlabels\r\n\n\nmetadata<-data.frame\\(labelDescription=c\\(\u201cArray\u201d, \u201cCondition\u201d, \u201cReplicate\u201d, \u201cCellLine\u201d), row.names=c\\(\u201cArray\u201d, \u201cCondition\u201d, \u201cReplicate\u201d, \u201ccellLine\u201d))\r\n\n\npD<-new\\(\"AnnotatedDataFrame\",data=phD, varMetadata=metadata)\r\n\n\n###Load the Illumina microarray annotations\r\n\n\nill.array <- read.csv\\(file=\"C:/Documents and Settings/dhglab.NEURODH/Desktop/Chip info/HumanRef-8_V2_11223162_B.csv\", header=T)\r\n\n\n###Normalize between arrays\r\n\n\nmatrizQ <-normalizeBetweenArrays\\(matriz,method=\"quantile\")\r\n\n\n###Apply Combat\r\n\n\nsamName<-labls\r\n\n\ncombat.list<- as.data.frame\\(cbind\\(samName, Samples\\[,9], Samples\\[,3]))\r\n\n\ncolnames\\(combat.list)<- c\\(\"Sample\", \"Batch\", \u201cCondition\u201d)\r\n\n\nwrite.xls\\(matrizQ,file=\"ComBatExpr.xls\", quote=F)\r\n\n\nwrite.xls\\(combat.list,file=\"ComBatList.txt\",quote=F)\r\n\n\nsource\\(\"C:/Documents and Settings/dhglab.NEURODH/Desktop/Study/ComBat.R\",local=T)\r\n\n\nComBat\\(\"ComBatExpr.xls\",\"ComBatList.txt\")\r\n\n\n###Create the exprSet object\r\n\n\n#Read in Combat adjusted data\r\n\n\nmatrizQ_adj<-read.table\\(\"Adjusted_ComBatExpr_1cond.xls\", header=T)\r\n\n\nrownames\\(matrizQ_adj)<- rownames\\(matriz)\r\n\n\nmatrizQ_adj<-as.matrix\\(matrizQ_adj)\r\n\n\neSet <- new\\(\"ExpressionSet\", exprs=matrizQ_adj, phenoData=pD)\r\n\n\neSet\r\n\n\nftdexp<-exprs\\(eSet)\r\n\n\n###Compare experimental conditions\r\n\n\n#all samples\r\n\n\nall.samples<-as.data.frame\\(ftdexp)\r\n\n\n#ratios for heatmap and ratio output\r\n\n\n#selecting the coefficients for single arrays\r\n\n\n#1. Controls\r\n\n\nall.contr.wt<-all.samples\\[,Samples$Condition ==\u201dWT\u201d]\r\n\n\nall.contrM.wt<-rowMeans\\(all.contr.wt)\r\n\n\nall.contr.v<-all.samples\\[,Samples$Condition ==\u201dV\u201d]\r\n\n\nall.contrM.v<-rowMeans\\(all.contr.v)\r\n\n\n#2. Exp\r\n\n\nall.exp.wt<-all.samples\\[,Samples$Condition ==\u201dWT\u201d]\r\n\n\nall.exp.m12<-all.samples\\[,Samples$Condition ==\u201dM12\u201d]\r\n\n\n#3. Ratios\r\n\n\nall.coef.WTV <-all.exp.wt-all.contrM.v\r\n\n\ncolnames\\(all.coef.WTV)<-paste\\(\u201cvsV\u201d, colnames\\(all.coef.WTV), sep=\u201d.\u201d)\r\n\n\nall.coef.M12V<-all.exp.m12-all.contrM.v\r\n\n\ncolnames\\(all.coef.M12V)<-paste\\(\u201cvsV\u201d, colnames\\(all.coef.M12V), sep=\u201d.\u201d)\r\n\n\nall.coef.M12WT<-all.exp.m12-all.contrM.wt\r\n\n\ncolnames\\(all.coef.M12WT)<-paste\\(\u201cvsWT\u201d, colnames\\(all.coef.M12WT), sep=\u201d.\u201d)\r\n\n\n#export the data\r\n\n\nmydata2<-cbind\\(rownames\\(all.coef.WTV), all.coef.WTV, all.coef.M12V, all.coef.M12WT)\r\n\n\nill.array.nodup<-ill.array\\[\\!duplicated\\(ill.array$Target),]\r\n\n\nmy.all.data<- merge\\(mydata2,ill.array.nodup, by.x=\"Target\",by.y=\"Target\")\r\n\n\nmydata3<-cbind\\(rownames\\(all.samples),all.samples)\r\n\n\ncolnames\\(mydata3)1<-\"Target\"\r\n\n\ncolnames\\(mydata3)\\[2:length\\(mydata3)]<- paste\\(colnames\\(mydata3)\\[2:length\\(mydata3)],\"exp\",sep=\".\")\r\n\n\nmy.all.data.new<-merge\\(my.all.data,mydata3,by.x=\"Target\",by.y=\"Target\")\r\n\n\nwrite.xls\\(my.all.data.new,\"Line167/rm_alldata_ratio_line167.xls\",quote=F)\r\n\n\n###Fit the data to a linear model\r\n\n\nTS<- Samples$Condition\r\n\n\nTS <- factor\\(TS, levels=unique\\(TS))\r\n\n\ndesign <- model.matrix\\(~0+TS)\r\n\n\ncolnames\\(design) <- levels\\(TS)\r\n\n\nfit<- lmFit\\(eSet, design)\r\n\n\ncont.anova <- makeContrasts\\(WTvsV.L167= WT \u2013 V,\r\n\n\nM12vsV.L167= M12 \u2013 V,\r\n\n\nM12vsWT.L167= M12 \u2013 WT,\r\n\n\nlevels=design)\r\n\n\nfit2.anova<- contrasts.fit\\(fit, cont.anova)\r\n\n\nfitb<- eBayes\\(fit2.anova)\r\n\n\n###Implement a statistical threshold:\r\n\n\nchosen.adjust<-\"none\"\r\n\n\nchosen.p<-0.05\r\n\n\ncurrent.contrast<-\"contrast\"\r\n\n\nresults<-decideTests\\(fit2.anova,adjust.method=chosen.adjust,p=as.numeric\\(chosen.p))\r\n\n\nwrite.fit\\(fitb,file=\"dummy.xls\",adjust=chosen.adjust,results=results)\r\n\n\ntreat.de<-read.table\\(file=\"dummy.xls\",head=T)\r\n\n\n###Output the data for comparisons\r\n\n\nmyNames<-names\\(treat.de)\r\n\n\nres.col<- which\\(regexpr\\(\"Res.\",myNames)>0)\r\n\n\nanovalist<- which\\(apply\\(treat.de\\[,res.col],1,function\\(x)any\\(x,na.rm=T)))\r\n\n\ntreat.de.anova<-treat.de\\[anovalist,]\r\n\n\nfitsel.tre2<-merge\\(treat.de.anova, ill.array.nodup, by.x=\"ID\",by.y=\"Target\")\r\n\n\ncolnames\\(fitsel.tre2)1<-\"Target\"\r\n\n\nfitsel.ratio<-merge\\(fitsel.tre2,my.all.data.new)\r\n\n\ncolnames\\(fitsel.ratio)\r\n\n\nmyNames <-names\\(fitsel.ratio)\r\n\n\n#selects the relevant columns for output\r\n\n\nres.col<- which\\(regexpr\\(\"Res.\",myNames)>0)\r\n\n\ncoefs.col <- which\\(regexpr\\(\"Coef.\",myNames)>0)\r\n\n\nts.col<- coefs.col+length\\(coefs.col)\r\n\n\npvals.col <- which\\(regexpr\\(\"p.value.\",myNames)>0)\r\n\n\nendcolumns.start<-length\\(fitsel.ratio)-\\(length\\(mydata2)-2)\r\n\n\nendcolumns.end<-length\\(fitsel.ratio)\r\n\n\nfitsel.ratio2<-cbind\\(\r\n\n\nTarget= fitsel.ratio$Target,\r\n\n\nTranscript=fitsel.ratio$Accession,\r\n\n\nSymbol=fitsel.ratio$Symbol,\r\n\n\nDefinition=fitsel.ratio$Definition,\r\n\n\nfitsel.ratio\\[,coefs.col],\r\n\n\nfitsel.ratio\\[,pvals.col],\r\n\n\nF=fitsel.ratio$F,\r\n\n\nF.p.value=fitsel.ratio$F.p.value,\r\n\n\nfitsel.ratio\\[,res.col],\r\n\n\nfitsel.ratio\\[,ts.col],\r\n\n\nProbeSequence=fitsel.ratio$Probe_Sequence,\r\n\n\nOntology=fitsel.ratio$Ontology,\r\n\n\nSynonym=fitsel.ratio$Synonym,\r\n\n\nfitsel.ratio\\[,29: 100]\r\n\n\n)\r\n\n\nfitsel.ratio2<-fitsel.ratio2\\[order\\(fitsel.ratio2$F,decreasing=T),]\r\n\n\nout.file<-paste\\(paste\\(current.contrast,chosen.adjust,chosen.p,sep=\"_\"),\"xls\",sep=\".\")\r\n\n\nwrite.xls\\(fitsel.ratio2,file=paste\\(\u201drm2BE_covariate_\u201d, out.file,sep=\"\"),quote=F)\r\n\n\n###Output the complete list of genes\r\n\n\nfitsel.treAll<-merge\\(treat.de, ill.array, by.x=\"ID\",by.y=\"Target\")\r\n\n\ncolnames\\(fitsel.treAll)1<-\"Target\"\r\n\n\nfitsel.ratioAll<-merge\\(fitsel.treAll,my.all.data.new)\r\n\n\nmyNames <-names\\(fitsel.ratio)\r\n\n\n#selects the relevant columns for output\r\n\n\nres.col<- which\\(regexpr\\(\"Res.\",myNames)>0)\r\n\n\ncoefs.col <- which\\(regexpr\\(\"Coef.\",myNames)>0)\r\n\n\nts.col<- coefs.col+length\\(coefs.col)\r\n\n\npvals.col <- which\\(regexpr\\(\"p.value.\",myNames)>0)\r\n\n\nendcolumns.start<-length\\(fitsel.ratio)-\\(length\\(mydata2)-2)\r\n\n\nendcolumns.end<-length\\(fitsel.ratio)\r\n\n\nfitsel.ratioN<-cbind\\(\r\n\n\nTarget= fitsel.ratioAll$Target,\r\n\n\nTranscript=fitsel.ratioAll$Accession,\r\n\n\nSymbol=fitsel.ratioAll$Symbol,\r\n\n\nDefinition=fitsel.ratioAll$Definition,\r\n\n\nfitsel.ratioAll\\[,coefs.col],\r\n\n\nfitsel.ratioAll\\[,pvals.col],\r\n\n\nF=fitsel.ratioAll$F,\r\n\n\nF.p.value=fitsel.ratioAll$F.p.value,\r\n\n\nfitsel.ratioAll\\[,res.col],\r\n\n\nfitsel.ratioAll\\[,ts.col],\r\n\n\nProbeSequence=fitsel.ratioAll$Probe_Sequence,\r\n\n\nOntology=fitsel.ratioAll$Ontology,\r\n\n\nSynonym=fitsel.ratioAll$Synonym,\r\n\n\nfitsel.ratioAll\\[,29:100]\r\n\n\n)\r\n\n\nfitsel.ratioN<-fitsel.ratioN\\[\\!duplicated\\(fitsel.ratioN$Target),]\r\n\n\nfitsel.ratioN<-fitsel.ratioN\\[order\\(fitsel.ratioN$F,decreasing=T),]\r\n\n\nwrite.xls\\(fitsel.ratioN,file=paste\\(\"rm2BE_covariate_genelist_all.xls\",sep=\"/\"),quote=F)\r\n\n\n2. ###This code is for analyzing the brain tissue data from Illumina Human Ref8-v3 arrays using R\r\n  ###The following abbreviations are used: FP=frontal pole; caud=caudate nucleus; hipp=hippocampus\r\n\n\nLoad packages\r\n\n\nlibrary \\(Biobase)\r\n\n\nlibrary\\(marray)\r\n\n\nlibrary \\(limma)\r\n\n\nlibrary\\(RColorBrewer)\r\n\n\nlibrary\\(MASS)\r\n\n\nlibrary\\(gplots)\r\n\n\n###Read in the dataset\r\n\n\nSamples<-read.delim\\(file=\"E:/Study/Human_Solexa_number2/Human_Solexa_Illumina_targets2.txt\", header=T)\r\n\n\nlabls<-as.character\\(paste\\(substr\\(Samples$Status,1,2), Samples$ConditionS, Samples$Replicate, sep=\u201d_\u201d))\r\n\n\nphD <- Samples\\[,c\\(1,2,3,5)]\r\n\n\nrownames\\(phD)<-labls\r\n\n\nmetadata<-data.frame\\(labelDescription=c\\(\u201cArrayID\u201d, \u201cGenotype\u201d,\u201cCondition\u201d, \u201cStatus\u201d), row.names= c\\(\u201cArrayID\u201d, \u201cGenotype\u201d,\u201cCondition\u201d, \u201cStatus\u201d))\r\n\n\npD<-new\\(\"AnnotatedDataFrame\",data=phD, varMetadata=metadata)\r\n\n\nillumina71<- read.delim \\(file=\"2008_071A_Sample_probe_profile.txt\", header=TRUE)\r\n\n\nrownames\\(illumina71)<-illumina71$PROBE_ID\r\n\n\nillumina71<-illumina71\\[,3:74]\r\n\n\nillumina43<- read.delim \\(file=\"Sample Probe profile 2008-043.txt\", header=TRUE)\r\n\n\nrownames\\(illumina43)<-illumina43$PROBE_ID\r\n\n\nillumina43<-illumina43\\[,11:12]\r\n\n\nillumina61<- read.delim \\(file=\"Sample probe profile 2008-061A.txt\", header=TRUE)\r\n\n\nrownames\\(illumina61)<-illumina61$PROBE_ID\r\n\n\nillumina61<-illumina61\\[,3:50]\r\n\n\nillumina2<-cbind\\(illumina61, illumina71) #add 43 later as it has 2 columns\r\n\n\n#signal values\r\n\n\nnsampl<-40\r\n\n\ncolnames\\(illumina2)\\[seq\\(1,\\(nsampl*3),3)]\r\n\n\nmydata<-illumina2\\[,seq\\(1,\\(nsampl*3),3)]\r\n\n\nmydata2<-cbind\\(mydata\\[,1:16], illumina43\\[,1], mydata\\[, 17:40])\r\n\n\ncolnames\\(mydata2)<-labls\r\n\n\nmydata<-mydata2\r\n\n\n#detction scores\r\n\n\ncolnames\\(illumina2)\\[seq\\(1,\\(nsampl*3),3)+1]\r\n\n\ndetsco<-illumina2\\[,seq\\(1,\\(nsampl*3),3)+1]\r\n\n\ndetsco2<-cbind\\(detsco\\[,1:16], illumina43\\[,2], detsco\\[, 17:40])\r\n\n\ndetsco<- detsco2\r\n\n\ncolnames\\(detsco)<-labls\r\n\n\ndetsco<-1- detsco #pvalue to real\r\n\n\nmydata.notlog<-mydata\r\n\n\nmydata=log2\\(mydata)\r\n\n\nmatriz <- as.matrix\\(mydata)\r\n\n\n###Load the Illumina microarray annotations\r\n\n\nill.array <- read.csv\\(file=\"C:/Documents and Settings/dhglab.NEURODH/Desktop/Chip info/HumanRef-8_V3_0_R0_11282963_A.csv\", header=T)\r\n\n\n#remove probes that are not a perfect match to either human or chimp genome\r\n\n\nbad.probe<-read.table\\(\u201cE:/Study/Human_Solexa_number2/Bad_Illumina_probes_for_Chimp_comp.txt\u201d, header=T)\r\n\n\ndim\\(bad.probe)\r\n\n\n#1 9305 1\r\n\n\ndim\\(mydata)\r\n\n\n#1 24526 41\r\n\n\nremoveProbes = match\\(bad.probe$PSID, rownames\\(mydata))\r\n\n\nmydata.g<-mydata\\[-removeProbes,]\r\n\n\ndetsco.g<-detsco\\[-removeProbes,]\r\n\n\ndim\\(mydata.g)\r\n\n\n# 15221 41\r\n\n\ndim\\(detsco.g)\r\n\n\nsave\\(mydata.g, detsco.g, bad.probe, mydata, file=\u201dgood_probes_data\u201d)\r\n\n\nmatriz<- as.matrix\\(mydata.g)\r\n\n\n###Normalize between arrays\r\n\n\nmatrizQQ <-normalizeBetweenArrays\\(matriz,method=\"quantile\")\r\n\n\n###Apply Combat\r\n\n\nsamName<-labls\r\n\n\ncombat.list<- as.data.frame\\(cbind\\(samName, Samples\\[,7], Samples\\[,4], Samples\\[,5]))\r\n\n\ncolnames\\(combat.list)<- c\\(\"SampleName\", \"Batch\", \u201cCondition\u201d)\r\n\n\nwrite.xls\\(matrizQ,file=\"ComBatExpr.xls\", quote=F)\r\n\n\nwrite.xls\\(combat.list,file=\"ComBatList.txt\",quote=F)\r\n\n\nsource\\(\"C:/Documents and Settings/dhglab.NEURODH/Desktop/Study/ComBat.R\",local=T)\r\n\n\nComBat\\(\"ComBatExpr.xls\",\"ComBatList.txt\")\r\n\n\n###Create the exprSet object\r\n\n\n#Read in Combat adjusted data\r\n\n\nmatrizQ_adj<-read.table\\(\"Adjusted_ComBatExpr.xls\", header=T)\r\n\n\nrownames\\(matrizQ_adj)<- rownames\\(matriz.g)\r\n\n\nmatrizQ_adj<-as.matrix\\(matrizQ_adj)\r\n\n\neSet <- new\\(\"ExpressionSet\", exprs=matrizQ_adj, phenoData=pD.g)\r\n\n\neSet\r\n\n\nftdexp<-exprs\\(eSet)\r\n\n\n###Compare experimental conditions\r\n\n\n#all samples\r\n\n\nall.samples<-as.data.frame\\(ftdexp)\r\n\n\n#1. Controls, each condition as a control\r\n\n\nall.contr.h <-all.samples\\[,Samples$Status==\u201dhuman\u201d ]\r\n\n\nall.contrM.h <-rowMeans\\(all.contr.h)\r\n\n\nall.contr.hh <-all.samples\\[,Samples$Status==\u201dhuman\u201d & Samples$ConditionS==\u201dhipp\u201d]\r\n\n\nall.contrM.hh <-rowMeans\\(all.contr.hh)\r\n\n\nall.contr.hc <-all.samples\\[,Samples$Status==\u201dhuman\u201d & Samples$ConditionS==\u201dcaud\u201d]\r\n\n\nall.contrM.hc <-rowMeans\\(all.contr.hc)\r\n\n\nall.contr.hf <-all.samples\\[,Samples$Status==\u201dhuman\u201d & Samples$ConditionS==\u201dFP\u201d]\r\n\n\nall.contrM.hf <-rowMeans\\(all.contr.hf)\r\n\n\nall.contr.cc <-all.samples\\[,Samples$Status==\u201dchimp\u201d & Samples$ConditionS==\u201dcaud\u201d]\r\n\n\nall.contrM.cc <-rowMeans\\(all.contr.cc)\r\n\n\nall.contr.cf <-all.samples\\[,Samples$Status==\u201dchimp\u201d & Samples$ConditionS==\u201dFP\u201d]\r\n\n\nall.contrM.cf <-rowMeans\\(all.contr.cf)\r\n\n\nall.contr.caud <-all.samples\\[,Samples$ConditionS==\u201dcaud\u201d]\r\n\n\nall.contrM.caud <-rowMeans\\(all.contr.caud)\r\n\n\nall.contr.fp <-all.samples\\[,Samples$ConditionS==\u201dFP\u201d]\r\n\n\nall.contrM.fp <-rowMeans\\(all.contr.fp)\r\n\n\n#2. Exp, each condition as a treatment\r\n\n\nall.exp.c<- all.samples\\[,Samples$Status==\u201dchimp\u201d]\r\n\n\nall.exp.hipp<- all.samples\\[,Samples$ConditionS==\u201dhipp\u201d]\r\n\n\nall.exp.caud<- all.samples\\[,Samples$ConditionS==\u201dcaud\u201d]\r\n\n\nall.exp.hh<- all.samples\\[,Samples$Status==\u201dhuman\u201d & Samples$ConditionS==\u201dhipp\u201d]\r\n\n\nall.exp.hc<- all.samples\\[,Samples$Status==\u201dhuman\u201d & Samples$ConditionS==\u201dcaud\u201d]\r\n\n\nall.exp.ch<- all.samples\\[,Samples$Status==\u201dchimp\u201d & Samples$ConditionS==\u201dhipp\u201d]\r\n\n\nall.exp.cc<- all.samples\\[,Samples$Status==\u201dchimp\u201d & Samples$ConditionS==\u201dcaud\u201d]\r\n\n\nall.exp.cf<- all.samples\\[,Samples$Status==\u201dchimp\u201d & Samples$ConditionS==\u201dFP\u201d]\r\n\n\n#3. Ratios\r\n\n\nall.coef.hhc<- all.exp.hh - all.contrM.hc\r\n\n\ncolnames\\(all.coef.hhc)<-paste\\(\u201cvsCAUD\u201d, colnames\\(all.coef.hhc), sep=\u201d.\u201d)\r\n\n\nall.coef.hhf<- all.exp.hh - all.contrM.hf\r\n\n\ncolnames\\(all.coef.hhf)<-paste\\(\u201cvsFP\u201d, colnames\\(all.coef.hhf), sep=\u201d.\u201d)\r\n\n\nall.coef.hcf<- all.exp.hc - all.contrM.hf\r\n\n\ncolnames\\(all.coef.hcf)<-paste\\(\u201cvsFP\u201d, colnames\\(all.coef.hcf), sep=\u201d.\u201d)\r\n\n\nall.coef.chc<- all.exp.ch - all.contrM.cc\r\n\n\ncolnames\\(all.coef.chc)<-paste\\(\u201cvsCAUD\u201d, colnames\\(all.coef.chc), sep=\u201d.\u201d)\r\n\n\nall.coef.chf<- all.exp.ch - all.contrM.cf\r\n\n\ncolnames\\(all.coef.chf)<-paste\\(\u201cvsFP\u201d, colnames\\(all.coef.chf), sep=\u201d.\u201d)\r\n\n\nall.coef.ccf<- all.exp.cc - all.contrM.cf\r\n\n\ncolnames\\(all.coef.ccf)<-paste\\(\u201cvsFP\u201d, colnames\\(all.coef.ccf), sep=\u201d.\u201d)\r\n\n\nall.coef.ch.hipp<- all.exp.ch - all.contrM.hh\r\n\n\ncolnames\\(all.coef.ch.hipp)<-paste\\(\u201cCHvsHUM\u201d, colnames\\(all.coef.ch.hipp), sep=\u201d.\u201d)\r\n\n\nall.coef.ch.caud<- all.exp.cc - all.contrM.hc\r\n\n\ncolnames\\(all.coef.ch.caud)<-paste\\(\u201cCHvsHUM\u201d, colnames\\(all.coef.ch.caud), sep=\u201d.\u201d)\r\n\n\nall.coef.ch.fp<- all.exp.cf - all.contrM.hf\r\n\n\ncolnames\\(all.coef.ch.fp)<-paste\\(\u201cCHvsHUM\u201d, colnames\\(all.coef.ch.fp), sep=\u201d.\u201d)\r\n\n\nall.coef.hipp.caud<- all.exp.hipp - all.contrM.caud\r\n\n\ncolnames\\(all.coef.hipp.caud)<-paste\\(\u201cHippvsCaud\u201d, colnames\\(all.coef.hipp.caud), sep=\u201d.\u201d)\r\n\n\nall.coef.hipp.fp<- all.exp.hipp - all.contrM.fp\r\n\n\ncolnames\\(all.coef.hipp.fp)<-paste\\(\u201cHippvsFP\u201d, colnames\\(all.coef.hipp.fp), sep=\u201d.\u201d)\r\n\n\nall.coef.caud.fp<- all.exp.caud - all.contrM.fp\r\n\n\ncolnames\\(all.coef.caud.fp)<-paste\\(\u201cCaudvsFP\u201d, colnames\\(all.coef.caud.fp), sep=\u201d.\u201d)\r\n\n\nall.coef.CH<- all.exp.c - all.contrM.h\r\n\n\ncolnames\\(all.coef.CH)<-paste\\(\u201cCHvsHUM\u201d, colnames\\(all.coef.CH), sep=\u201d.\u201d)\r\n\n\n#export the data\r\n\n\nmydata2<-cbind\\(rownames\\(all.coef.hhc), all.coef.hhc, all.coef.hhf, all.coef.hcf, all.coef.chc, all.coef.chf, all.coef.ccf, all.coef.ch.hipp, all.coef.ch.caud, all.coef.ch.fp, all.coef.hipp.caud, all.coef.hipp.fp, all.coef.caud.fp, all.coef.CH)\r\n\n\ncolnames\\(mydata2)1<-\u201cTarget\u201d\r\n\n\nill.array.nodup<-ill.array\\[\\!duplicated\\(ill.array$Probe_Id),]\r\n\n\nmy.all.data<- merge\\(mydata2,ill.array.nodup, by.x=\"Target\",by.y=\"Probe_Id\")\r\n\n\nmydata3<-cbind\\(rownames\\(all.samples),all.samples)\r\n\n\ncolnames\\(mydata3)1<-\"Target\"\r\n\n\ncolnames\\(mydata3)\\[2:length\\(mydata3)]<- paste\\(colnames\\(mydata3)\\[2:length\\(mydata3)],\"exp\",sep=\".\")\r\n\n\nmy.all.data.new<-merge\\(my.all.data,mydata3,by.x=\"Target\",by.y=\"Target\")\r\n\n\nratio_exp<-merge\\(mydata2,mydata3,by.x=\"Target\",by.y=\"Target\")\r\n\n\nwrite.xls\\(my.all.data.new,\"alldata_ratio.xls\",quote=F)\r\n\n\n###Fit the data to a linear model\r\n\n\nTS<- paste\\(Samples$Status, Samples$ConditionS, sep=\u201d_\u201d)\r\n\n\nTS <- factor\\(TS, levels=unique\\(TS))\r\n\n\ndesign <- model.matrix\\(~0+TS)\r\n\n\ncolnames\\(design) <- levels\\(TS)\r\n\n\nfit<- lmFit\\(eSet, design)\r\n\n\ncont.anova <- makeContrasts\\(HIPPvsCAUD_human= human_hipp \u2013 human_caud,\r\n\n\nHIPPvsFP_human= human_hipp \u2013 human_FP,\r\n\n\nCAUDvsFP_human= human_caud \u2013 human_FP,\r\n\n\nHIPPvsCAUD_chimp= chimp_hipp \u2013 chimp_caud,\r\n\n\nHIPPvsFP_chimp= chimp_hipp \u2013 chimp_FP,\r\n\n\nCAUDvsFP_chimp= chimp_caud \u2013 chimp_FP,\r\n\n\nCHvsHUM_hipp= chimp_hipp \u2013 human_hipp,\r\n\n\nCHvsHUM_caud= chimp_caud \u2013 human_caud,\r\n\n\nCHvsHUM_FP= chimp_FP \u2013 human_FP,\r\n\n\nHIPPvsCAUD = \\(human_hipp + chimp_hipp)/2 \u2013 \\(human_caud + chimp_caud)/2,\r\n\n\nHIPPvsFP = \\(human_hipp + chimp_hipp)/2 \u2013 \\(human_FP + chimp_FP)/2,\r\n\n\nCAUDvsFP = \\(human_caud + chimp_caud)/2 \u2013 \\(human_FP + chimp_FP)/2,\r\n\n\nCHIMPvsHUMAN = \\(chimp_hipp+ chimp_caud+ chimp_FP)/3 -\\(human_hipp+ human_caud+ human_FP)/3,\r\n\n\nlevels=design)\r\n\n\nfit2.anova<- contrasts.fit\\(fit, cont.anova)\r\n\n\nfitb<- eBayes\\(fit2.anova)\r\n\n\n###Implement a statistical threshold:\r\n\n\nchosen.adjust<-\"none\"\r\n\n\nchosen.p<-0.05\r\n\n\ncurrent.contrast<-\"contrast\"\r\n\n\nresults<-decideTests\\(fitb,adjust.method=chosen.adjust,p=as.numeric\\(chosen.p))\r\n\n\nwrite.fit\\(fitb,file=\"dummyrr.xls\",adjust=chosen.adjust,results=results)\r\n\n\ntreat.de<-read.table\\(file=\"dummyrr.xls\",head=T)\r\n\n\nmyNames<-names\\(treat.de)\r\n\n\nres.col<- which\\(regexpr\\(\"Res.\",myNames)>0)\r\n\n\nanovalist<- which\\(apply\\(treat.de\\[,res.col],1,function\\(x)any\\(x,na.rm=T)))\r\n\n\ntreat.de.anova<-treat.de\\[anovalist,]\r\n\n\nill.array.nodup<-ill.array\\[\\!duplicated\\(ill.array$Probe_Id),]\r\n\n\nfitsel.tre2<-merge\\(treat.de.anova, ill.array.nodup, by.x=\"ID\",by.y=\"Probe_Id\")\r\n\n\ncolnames\\(fitsel.tre2)1<-\"Probe\"\r\n\n\nfitsel.ratio<-merge\\(fitsel.tre2,ratio_exp, by.x=\u201dProbe\u201d, by.y=\u201dTarget\u201d)\r\n\n\n###Output the data for comparisons\r\n\n\nmyNames <-names\\(fitsel.ratio)\r\n\n\n#selects the relevant columns for output\r\n\n\nres.col<- which\\(regexpr\\(\"Res.\",myNames)>0)\r\n\n\ncoefs.col <- which\\(regexpr\\(\"Coef.\",myNames)>0)\r\n\n\nts.col<- coefs.col+length\\(coefs.col)\r\n\n\npvals.col <- which\\(regexpr\\(\"p.value.\",myNames)>0)\r\n\n\nendcolumns.start<-length\\(fitsel.ratio)-\\(length\\(mydata2)-2)\r\n\n\nendcolumns.end<-length\\(fitsel.ratio)\r\n\n\nfitsel.ratio2<-cbind\\(\r\n\n\nProbe= fitsel.ratio$Probe,\r\n\n\nAccession=fitsel.ratio$Accession,\r\n\n\nSymbol=fitsel.ratio$Symbol,\r\n\n\nDefinition=fitsel.ratio$Definition,\r\n\n\nfitsel.ratio\\[,coefs.col],\r\n\n\nfitsel.ratio\\[,pvals.col],\r\n\n\nF=fitsel.ratio$F,\r\n\n\nF.p.value=fitsel.ratio$F.p.value,\r\n\n\nfitsel.ratio\\[,res.col],\r\n\n\nfitsel.ratio\\[,ts.col],\r\n\n\nA= fitsel.ratio$A,\r\n\n\nfitsel.ratio\\[,84:226],\r\n\n\nfitsel.ratio\\[,57:66],\r\n\n\nfitsel.ratio\\[,69:77],\r\n\n\nfitsel.ratio\\[,79:83]\r\n\n\n)\r\n\n\nfitsel.ratio2<-fitsel.ratio2\\[order\\(fitsel.ratio2$F,decreasing=T),]\r\n\n\nout.file<-paste\\(paste\\(current.contrast,chosen.adjust,chosen.p,sep=\"_\"),\"xls\",sep=\".\")\r\n\n\nwrite.xls\\(fitsel.ratio2, \u201ccombat_significant_genelist_0.05.xls\u201d, quote=F)\r\n\n\n###Output the complete list of genes\r\n\n\nfitsel.treAll<-merge\\(treat.de, ill.array.nodup, by.x=\"ID\",by.y=\"Probe_Id\")\r\n\n\ncolnames\\(fitsel.treAll)1<-\"Probe\"\r\n\n\nfitsel.ratioAll<-merge\\(fitsel.treAll, ratio_exp, by.x=\u201dProbe\u201d, by.y=\u201dTarget\u201d)\r\n\n\nmyNames <-names\\(fitsel.ratioAll)\r\n\n\n#selects the relevant columns for output\r\n\n\nres.col<- which\\(regexpr\\(\"Res.\",myNames)>0)\r\n\n\ncoefs.col <- which\\(regexpr\\(\"Coef.\",myNames)>0)\r\n\n\nts.col<- coefs.col+length\\(coefs.col)\r\n\n\npvals.col <- which\\(regexpr\\(\"p.value.\",myNames)>0)\r\n\n\nendcolumns.start<-length\\(fitsel.ratio)-\\(length\\(mydata2)-2)\r\n\n\nendcolumns.end<-length\\(fitsel.ratio)\r\n\n\nfitsel.ratioN<-cbind\\(\r\n\n\nProbe= fitsel.ratioAll$Probe,\r\n\n\nAccession=fitsel.ratioAll$Accession,\r\n\n\nSymbol=fitsel.ratioAll$Symbol,\r\n\n\nDefinition=fitsel.ratioAll$Definition,\r\n\n\nfitsel.ratioAll\\[,coefs.col],\r\n\n\nfitsel.ratioAll\\[,pvals.col],\r\n\n\nF=fitsel.ratioAll$F,\r\n\n\nF.p.value=fitsel.ratioAll$F.p.value,\r\n\n\nfitsel.ratioAll\\[,res.col],\r\n\n\nfitsel.ratioAll\\[,ts.col],\r\n\n\nA= fitsel.ratioAll$A,\r\n\n\nfitsel.ratioAll\\[,84:226],\r\n\n\nfitsel.ratioAll\\[,57:66],\r\n\n\nfitsel.ratioAll\\[,69:77],\r\n\n\nfitsel.ratioAll\\[,79:83]\r\n\n\n)\r\n\n\ndim\\(fitsel.ratioN)\r\n\n\nfitsel.ratioN<-fitsel.ratioN\\[order\\(fitsel.ratioN$F,decreasing=T),]\r\n\n\nwrite.xls\\(fitsel.ratioN,file= \"combat_complete_genelist.xls\",quote=F)\r\n\n\n3. ###This code is for analyzing the SH-SY5Y microarray data using WGCNA \\(weighted gene coexpression network analysis) using R\r\n  ###Paste the following functions into R\r\n\n\nPickSoftThreshold=function\\(datExpr1,RsquaredCut=0.85, powervector=c\\(seq\\(1,10,by=1),seq\\(12,20,by=2)),removeFirst=FALSE,no.breaks=10) \\{\r\n\n\nno.genes <- dim\\(datExpr1)\\[2]\r\n\n\nno.genes <- dim\\(datExpr1)\\[2]\r\n\n\nno.samples= dim\\(datExpr1)\\[1]\r\n\n\ncolname1=c\\(\"Power\", \"scale law R2\" ,\"slope\", \"truncated R2\",\"mean\\(k)\",\"median\\(k)\",\"max\\(k)\")\r\n\n\ndatout=data.frame\\(matrix\\(666,nrow=length\\(powervector),ncol=length\\(colname1) ))\r\n\n\nnames\\(datout)=colname1\r\n\n\ndatout\\[,1]=powervector\r\n\n\nif\\(exists\\(\"fun1\")) rm\\(fun1)\r\n\n\nfun1=function\\(x) \\{\r\n\n\ncorx=abs\\(cor\\(x,datExpr1,use=\"p\"))\r\n\n\nout1=rep\\(NA, length\\(powervector) )\r\n\n\nfor \\(j in c\\(1:length\\(powervector))) \\{out1\\[j]=sum\\(corx^powervector\\[j])}\r\n\n\nout1\r\n\n\n} # end of fun1\r\n\n\n\r\n\n\ndatk=t\\(apply\\(datExpr1,2,fun1))\r\n\n\nfor \\(i in c\\(1:length\\(powervector) ) )\\{\r\n\n\nnolinkshelp <- datk\\[,i]-1\r\n\n\ncut2=cut\\(nolinkshelp,no.breaks)\r\n\n\nbinned.k=tapply\\(nolinkshelp,cut2,mean)\r\n\n\nfreq1=as.vector\\(tapply\\(nolinkshelp,cut2,length)/length\\(nolinkshelp))\r\n\n\n# The following code corrects for missing values etc\r\n\n\nbreaks1=seq\\(from=min\\(nolinkshelp),to=max\\(nolinkshelp),length=no.breaks+1)\r\n\n\nhist1=hist\\(nolinkshelp,breaks=breaks1,equidist=F,plot=FALSE,right=TRUE)\r\n\n\nbinned.k2=hist1$mids\r\n\n\nbinned.k=ifelse\\(is.na\\(binned.k),binned.k2,binned.k)\r\n\n\nbinned.k=ifelse\\(binned.k==0,binned.k2,binned.k)\r\n\n\nfreq1=ifelse\\(is.na\\(freq1),0,freq1)\r\n\n\nxx= as.vector\\(log10\\(binned.k))\r\n\n\nif\\(removeFirst) \\{freq1=freq1\\[-1]; xx=xx\\[-1]}\r\n\n\nplot\\(xx,log10\\(freq1+.000000001),xlab=\"log10\\(k)\",ylab=\"log10\\(p\\(k))\" )\r\n\n\nlm1= lm\\(as.numeric\\(log10\\(freq1+.000000001))~ xx )\r\n\n\nlm2=lm\\(as.numeric\\(log10\\(freq1+.000000001))~ xx+I\\(10^xx) )\r\n\n\ndatout\\[i,2]=summary\\(lm1)$adj.r.squared\r\n\n\ndatout\\[i,3]=summary\\(lm1)$coefficients\\[2,1]\r\n\n\ndatout\\[i,4]=summary\\(lm2)$adj.r.squared\r\n\n\ndatout\\[i,5]=mean\\(nolinkshelp)\r\n\n\ndatout\\[i,6]= median\\(nolinkshelp)\r\n\n\ndatout\\[i,7]= max\\(nolinkshelp)\r\n\n\n}\r\n\n\ndatout=signif\\(datout,3)\r\n\n\nprint\\(data.frame\\(datout));\r\n\n\n# the cut-off is chosen as smallest cut with R^2>RsquaredCut\r\n\n\nind1=datout\\[,2]>RsquaredCut\r\n\n\nindcut=NA\r\n\n\nindcut=ifelse\\(sum\\(ind1)>0,min\\(c\\(1:length\\(ind1))\\[ind1]),indcut)\r\n\n\n# this estimates the power value that should be used.\r\n\n\n# Don't trust it. You need to consider slope and mean connectivity as well\\!\r\n\n\npower.estimate=powervector\\[indcut]\\[1]\r\n\n\nlist\\(power.estimate, data.frame\\(datout));\r\n\n\n}\r\n\n\nTOMdist1=function\\(adjmat1, maxADJ=FALSE) \\{\r\n\n\ndiag\\(adjmat1)=0;\r\n\n\nadjmat1\\[is.na\\(adjmat1)]=0;\r\n\n\nmaxh1=max\\(as.dist\\(adjmat1) ); minh1=min\\(as.dist\\(adjmat1) );\r\n\n\nif \\(maxh1>1 | minh1 < 0 ) \\{print\\(paste\\(\"ERROR: the adjacency matrix contains entries that are larger than 1 or smaller than 0\\!\\!\\!, max=\",maxh1,\", min=\",minh1)) } else \\{\r\n\n\nif \\( max\\(c\\(as.dist\\(abs\\(adjmat1-t\\(adjmat1)))))>0 ) \\{print\\(\"ERROR: non-symmetric adjacency matrix\\!\\!\\!\") } else \\{\r\n\n\nkk=apply\\(adjmat1,2,sum)\r\n\n\nmaxADJconst=1\r\n\n\nif \\(maxADJ==TRUE) maxADJconst=max\\(c\\(as.dist\\(adjmat1 )))\r\n\n\nDhelp1=matrix\\(kk,ncol=length\\(kk),nrow=length\\(kk))\r\n\n\ndenomTOM= pmin\\(as.dist\\(Dhelp1),as.dist\\(t\\(Dhelp1))) +as.dist\\(maxADJconst-adjmat1);\r\n\n\ngc\\();gc\\();\r\n\n\nnumTOM=as.dist\\(adjmat1 %*% adjmat1 +adjmat1);\r\n\n\n#TOMmatrix=numTOM/denomTOM\r\n\n\n# this turns the TOM matrix into a dissimilarity\r\n\n\nout1=1-as.matrix\\(numTOM/denomTOM)\r\n\n\ndiag\\(out1)=1\r\n\n\nout1\r\n\n\n} \r\n\n\n}\r\n\n\n}\r\n\n\nmakeNetwork = function\\(dat,beta,signed=0)\\{\r\n\n\nif\\(signed==0)\\{\r\n\n\na = abs\\(cor\\(dat,use=\"p\")^beta)\r\n\n\nt = TOMdist1\\(a)\r\n\n\nreturn\\(hclust\\(as.dist\\(t),method=\"av\"))\r\n\n\n}else\\{\r\n\n\na = cor\\(dat,use=\"p\")\r\n\n\nb = a < 0\r\n\n\na\\[b] = 0\r\n\n\na = a^beta\r\n\n\nt = TOMdist1\\(a)\r\n\n\nreturn\\(hclust\\(as.dist\\(t),method=\"av\"))\r\n\n\n}\r\n\n\n}\r\n\n\ncutreeDynamic = function\\(hierclust, maxTreeHeight=1, deepSplit=TRUE, minModuleSize=50, minAttachModuleSize=100, nameallmodules=FALSE, useblackwhite=FALSE)\r\n\n\n\\{\r\n\n\nif\\(maxTreeHeight >=1)\\{\r\n\n\nstaticCutCluster = cutTreeStatic\\(hiercluster=hierclust, heightcutoff=0.99, minsize1=minModuleSize)\r\n\n\n}else\\{\r\n\n\nstaticCutCluster = cutTreeStatic\\(hiercluster=hierclust, heightcutoff=maxTreeHeight, minsize1=minModuleSize)\r\n\n\n}\r\n\n\n#get tree height for every singleton\r\n\n\n#node_index tree_height\r\n\n\ndemdroHeiAll= rbind\\( cbind\\(hierclust$merge\\[,1], hierclust$height), cbind\\(hierclust$merge\\[,2], hierclust$height) )\r\n\n\n#singletons will stand at the front of the list\r\n\n\nmyorder = order\\(demdroHeiAll\\[,1])\r\n\n\n#get # of singletons\r\n\n\nno.singletons = length\\(hierclust$order)\r\n\n\ndemdroHeiAll.sort = demdroHeiAll\\[myorder, ]\r\n\n\ndemdroHei.sort = demdroHeiAll.sort\\[c\\(1:no.singletons), ]\r\n\n\ndemdroHei = demdroHei.sort\\[seq\\(no.singletons, 1, by=-1), ]\r\n\n\ndemdroHei\\[,1] = -demdroHei\\[,1]\r\n\n\n# combine with prelimilary cluster-cutoff results\r\n\n\ndemdroHei = cbind\\(demdroHei, as.integer\\(staticCutCluster))\r\n\n\n# re-order the order based on the dendrogram order hierclust$order\r\n\n\ndemdroHei.order = demdroHei\\[hierclust$order, ]\r\n\n\nstatic.clupos = locateCluster\\(demdroHei.order\\[, 3])\r\n\n\nif \\(is.null\\(static.clupos) )\\{\r\n\n\nmodule.assign = rep\\(0, no.singletons)\r\n\n\ncolcode.reduced = assignModuleColor\\(module.assign, minsize1=minModuleSize, anameallmodules=nameallmodules, auseblackwhite=useblackwhite)\r\n\n\nreturn \\( colcode.reduced )\r\n\n\n}\r\n\n\nstatic.no = dim\\(static.clupos)1\r\n\n\nstatic.clupos2 = static.clupos\r\n\n\nstatic.no2 = static.no\r\n\n\n#split individual cluster if there are sub clusters embedded\r\n\n\nmcycle=1\r\n\n\nwhile\\(1==1)\\{\r\n\n\nclupos = NULL\r\n\n\nfor \\(i in c\\(1:static.no))\\{\r\n\n\nmydemdroHei.order = demdroHei.order\\[ c\\(static.clupos\\[i,1]:static.clupos\\[i,2]), ] #index to \\[1, clusterSize]\r\n\n\nmydemdroHei.order\\[, 1] = mydemdroHei.order\\[, 1] - static.clupos\\[i, 1] + 1\r\n\n\n#cat\\(\"Cycle \", as.character\\(mcycle), \"cluster \\(\", static.clupos\\[i,1], static.clupos\\[i,2], \")\\n\")\r\n\n\n#cat\\(\"i=\", as.character\\(i), \"\\n\")\r\n\n\niclupos = processInvididualCluster\\(mydemdroHei.order,\r\n\n\ncminModuleSize = minModuleSize,\r\n\n\ncminAttachModuleSize = minAttachModuleSize)\r\n\n\niclupos\\[,1] = iclupos\\[,1] + static.clupos\\[i, 1] -1 #recover the original index\r\n\n\niclupos\\[,2] = iclupos\\[,2] + static.clupos\\[i, 1] -1\r\n\n\nclupos = rbind\\(clupos, iclupos) #put in the final output buffer\r\n\n\n}\r\n\n\nif\\(deepSplit==FALSE)\\{\r\n\n\nbreak\r\n\n\n}\r\n\n\nif\\(dim\\(clupos)1 \\!= static.no) \\{\r\n\n\nstatic.clupos = clupos\r\n\n\nstatic.no = dim\\(static.clupos)1\r\n\n\n}else\\{\r\n\n\nbreak\r\n\n\n}\r\n\n\nmcycle = mcycle + 1\r\n\n\n#static.clupos\r\n\n\n}\r\n\n\nfinal.cnt = dim\\(clupos)1\r\n\n\n#assign colors for modules\r\n\n\nmodule.assign = rep\\(0, no.singletons)\r\n\n\nmodule.cnt=1\r\n\n\nfor \\(i in c\\(1:final.cnt ))\r\n\n\n\\{\r\n\n\nsdx = clupos\\[i, 1] #module start point\r\n\n\nedx = clupos\\[i, 2] #module end point\r\n\n\nmodule.size = edx - sdx +1\r\n\n\nif\\(module.size\n= minsize1\r\n\n\nno.modules=sum\\(modulebranch)\r\n\n\ncolorhelp = rep\\(-1, length\\(labelpred) )\r\n\n\nif \\( no.modules==0)\\{\r\n\n\nprint\\(\"No module detected\")\r\n\n\n}\r\n\n\nelse\\{\r\n\n\nfor \\(i in c\\(1:no.modules)) \\{\r\n\n\ncolorhelp=ifelse\\(labelpred==modulename\\[i],i ,colorhelp)\r\n\n\n}\r\n\n\n}\r\n\n\ncolorhelp\r\n\n\n}\r\n\n\nlocateCluster = function\\(clusterlabels)\r\n\n\n\\{\r\n\n\nno.nodes = length\\(clusterlabels)\r\n\n\nclusterlabels.shift = c\\(clusterlabels1, c\\(clusterlabels\\[1:\\(no.nodes-1)]) )\r\n\n\n#a non-zero point is the start point of a cluster and it previous point is the end point of the previous cluster\r\n\n\nlabel.diff = abs\\(clusterlabels - clusterlabels.shift)\r\n\n\n#process the first and last positions as start/end points if they belong to a cluster instead of no cluster \"-1\"\r\n\n\nif\\(clusterlabels1 >0) \\{label.diff1=1}\r\n\n\nif\\(clusterlabels\\[no.nodes]>0) \\{label.diff\\[no.nodes]=1}\r\n\n\nflagpoints.bool = label.diff > 0\r\n\n\nif\\( sum\\(flagpoints.bool) ==0)\\{\r\n\n\nreturn\\(NULL)\r\n\n\n}\r\n\n\nflagpoints = c\\(1:no.nodes)\\[flagpoints.bool]\r\n\n\nno.points = length\\(flagpoints)\r\n\n\nmyclupos=NULL\r\n\n\nfor\\(i in c\\(1:\\(no.points-1)) )\\{\r\n\n\nidx = flagpoints\\[i]\r\n\n\nif\\(clusterlabels\\[idx]>0)\\{\r\n\n\nmyclupos = rbind\\(myclupos, c\\(idx, flagpoints\\[i+1]-1) )\r\n\n\n}\r\n\n\n}\r\n\n\nmyclupos\r\n\n\n}\r\n\n\nprocessInvididualCluster = function\\(clusterDemdroHei, cminModuleSize=50, cminAttachModuleSize=100, minTailRunlength=12, useMean=0)\\{\r\n\n\n#for debug: use all genes\r\n\n\n#clusterDemdroHei =demdroHei.order\r\n\n\nno.cnodes = dim\\(clusterDemdroHei)1\r\n\n\ncmaxhei = max\\(clusterDemdroHei\\[, 2])\r\n\n\ncminhei = min\\(clusterDemdroHei\\[, 2])\r\n\n\ncmeanhei = mean\\(clusterDemdroHei\\[, 2])\r\n\n\ncmidhei = \\(cmeanhei + cmaxhei)/2.0\r\n\n\ncdwnhei = \\(cmeanhei + cminhei)/2.0\r\n\n\nif \\(useMean==1)\\{\r\n\n\ncomphei = cmidhei\r\n\n\n}else if \\(useMean==-1)\\{\r\n\n\ncomphei = cdwnhei\r\n\n\n}else\\{ #normal case\r\n\n\ncomphei = cmeanhei\r\n\n\n}\r\n\n\n# compute height diffrence with mean height\r\n\n\nheidiff = clusterDemdroHei\\[,2] - comphei\r\n\n\nheidiff.shift = shiftSequence\\(heidiff, -1)\r\n\n\n# get cut positions\r\n\n\n# detect the end point of a cluster, whose height should be less than meanhei\r\n\n\n# and the node behind it is the start point of the next cluster which has a height above meanhei\r\n\n\ncuts.bool = \\(heidiff<0) & \\(heidiff.shift > 0)\r\n\n\ncuts.bool1 = TRUE\r\n\n\ncuts.bool\\[no.cnodes] = TRUE\r\n\n\nif\\(sum\\(cuts.bool)==2)\\{\r\n\n\nif \\(useMean==0)\\{\r\n\n\nnew.clupos=processInvididualCluster\\(clusterDemdroHei=clusterDemdroHei, cminModuleSize=cminModuleSize,\r\n\n\ncminAttachModuleSize=cminAttachModuleSize,\r\n\n\nuseMean=1)\r\n\n\n}else if\\(useMean==1)\\{\r\n\n\nnew.clupos=processInvididualCluster\\(clusterDemdroHei=clusterDemdroHei, cminModuleSize=cminModuleSize,\r\n\n\ncminAttachModuleSize=cminAttachModuleSize,\r\n\n\nuseMean=-1)\r\n\n\n}else\\{\r\n\n\nnew.clupos = rbind\\(c\\(1, no.cnodes))\r\n\n\n}\r\n\n\nreturn \\(new.clupos)\r\n\n\n}\r\n\n\n#a good candidate cluster-end point should have significant # of ahead nodes with head < meanHei\r\n\n\ncutindex =c\\(1:no.cnodes)\\[cuts.bool]\r\n\n\nno.cutps = length\\(cutindex)\r\n\n\nrunlens = rep\\(999, no.cutps)\r\n\n\ncuts.bool2 = cuts.bool\r\n\n\nfor\\(i in c\\(2:\\(no.cutps-1)) )\\{\r\n\n\nseq = c\\( \\(cutindex\\[i-1]+1):cutindex\\[i] )\r\n\n\nrunlens\\[i] = runlengthSign\\(heidiff\\[seq], leftOrright=-1, mysign=-1)\r\n\n\nif\\(runlens\\[i] < minTailRunlength)\\{\r\n\n\n#cat\\(\"run length=\", runlens\\[i], \"\\n\")\r\n\n\ncuts.bool2\\[ cutindex\\[i] ] = FALSE\r\n\n\n}\r\n\n\n}\r\n\n\n#attach SMALL cluster to the left-side BIG cluster if the small one has smaller mean height\r\n\n\ncuts.bool3=cuts.bool2\r\n\n\nif\\(sum\\(cuts.bool2) > 3) \\{\r\n\n\ncurj = 2\r\n\n\nwhile \\(1==1)\\{\r\n\n\ncutindex2 =c\\(1:no.cnodes)\\[cuts.bool2]\r\n\n\nno.clus = length\\(cutindex2) -1\r\n\n\nif \\(curj>no.clus)\\{\r\n\n\nbreak\r\n\n\n}\r\n\n\npre.sdx = cutindex2\\[ curj-1 ]+1 #previous module start point\r\n\n\npre.edx = cutindex2\\[ curj ] #previous module end point\r\n\n\npre.module.size = pre.edx - pre.sdx +1\r\n\n\npre.module.hei = mean\\(clusterDemdroHei\\[c\\(pre.sdx:pre.edx) , 2])\r\n\n\ncur.sdx = cutindex2\\[ curj ]+1 #previous module start point\r\n\n\ncur.edx = cutindex2\\[ curj+1 ] #previous module end point\r\n\n\ncur.module.size = cur.edx - cur.sdx +1\r\n\n\ncur.module.hei = mean\\(clusterDemdroHei\\[c\\(cur.sdx:cur.edx) , 2])\r\n\n\n#merge to the leftside major module, don't change the current index \"curj\"\r\n\n\n#if\\( \\(pre.module.size >minAttachModuleSize)&\\(cur.module.hei\n2)\\{\r\n\n\nif\\( \\(cutindex2\\[no.cutps] - cutindex2\\[no.cutps-1]+1) < cminModuleSize )\\{\r\n\n\ncuts.bool2\\[ cutindex2\\[no.cutps-1] ] =FALSE\r\n\n\n}\r\n\n\n}\r\n\n\nif\\(1==2)\\{\r\n\n\nmyseqnce = c\\(2300:3000)\r\n\n\ncutdisp = ifelse\\(cuts.bool2==T, \"red\",\"grey\" )\r\n\n\n#re-order to the normal one with sequential signleton index\r\n\n\npar\\(mfrow=c\\(3,1), mar=c\\(0,0,0,0) )\r\n\n\nplot\\(h1row, labels=F, xlab=\"\",ylab=\"\",main=\"\",sub=\"\",axes = F)\r\n\n\nbarplot\\(heidiff\\[myseqnce],\r\n\n\ncol= \"black\", space=0,\r\n\n\nborder=F,main=\"\", axes = F, axisnames = F)\r\n\n\nbarplot\\(height=rep\\(1, length\\(cutdisp\\[myseqnce])),\r\n\n\ncol= as.character\\(cutdisp\\[myseqnce]), space=0,\r\n\n\nborder=F,main=\"\", axes = F, axisnames = F)\r\n\n\npar\\(mfrow=c\\(1,1), mar=c\\(5, 4, 4, 2) + 0.1)\r\n\n\n}\r\n\n\ncutindex2 = c\\(1:no.cnodes)\\[cuts.bool2]\r\n\n\ncutindex21=cutindex21-1 #the first\r\n\n\nno.cutps2 = length\\(cutindex2)\r\n\n\nif\\(no.cutps2 > 2)\\{\r\n\n\nnew.clupos = cbind\\( cutindex2\\[c\\(1:\\(no.cutps2-1))]+1, cutindex2\\[c\\(2:no.cutps2)] )\r\n\n\n}else\\{\r\n\n\nnew.clupos = cbind\\( 1, no.cnodes)\r\n\n\n}\r\n\n\nif \\( dim\\(new.clupos)1 == 1 )\\{\r\n\n\nif \\(useMean==0)\\{\r\n\n\nnew.clupos=processInvididualCluster\\(clusterDemdroHei=clusterDemdroHei, cminModuleSize=cminModuleSize,\r\n\n\ncminAttachModuleSize=cminAttachModuleSize,\r\n\n\nuseMean=1)\r\n\n\n}else if\\(useMean==1)\\{\r\n\n\nnew.clupos=processInvididualCluster\\(clusterDemdroHei=clusterDemdroHei, cminModuleSize=cminModuleSize,\r\n\n\ncminAttachModuleSize=cminAttachModuleSize,\r\n\n\nuseMean=-1)\r\n\n\n}\r\n\n\n}\r\n\n\nnew.clupos\r\n\n\n}\r\n\n\nshiftSequence = function\\(mysequence, delta)\\{\r\n\n\nseqlen = length\\(mysequence)\r\n\n\nif\\(delta>0)\\{\r\n\n\nfinalseq=c\\(mysequence\\[1:delta], mysequence\\[1:\\(seqlen-delta)])\r\n\n\n}else\\{\r\n\n\nposdelta = -delta\r\n\n\nfinalseq=c\\(mysequence\\[\\(posdelta+1):seqlen], mysequence\\[\\(seqlen-posdelta+1):seqlen])\r\n\n\n}\r\n\n\nfinalseq\r\n\n\n}\r\n\n\nrunlengthSign = function\\(mysequence, leftOrright=-1, mysign=-1)\\{\r\n\n\nseqlen = length\\(mysequence)\r\n\n\nif\\(leftOrright<0)\\{\r\n\n\npseq = rev\\(mysequence)\r\n\n\n}else\\{\r\n\n\npseq = mysequence\r\n\n\n}\r\n\n\nif\\(mysign<0)\\{ #see where the first POSITIVE number occurs\r\n\n\nnonezero.bool = \\(pseq > 0)\r\n\n\n}else\\{ #see where the first NEGATIVE number occur\r\n\n\nnonezero.bool = \\(pseq < 0)\r\n\n\n}\r\n\n\nif\\( sum\\(nonezero.bool) > 0)\\{\r\n\n\nrunlength = min\\( c\\(1:seqlen)\\[nonezero.bool] ) - 1\r\n\n\n}else\\{\r\n\n\nrunlength = 0\r\n\n\n}\r\n\n\n}\r\n\n\nassignModuleColor = function\\(labelpred, minsize1=50, anameallmodules=FALSE, auseblackwhite=FALSE) \\{\r\n\n\n# here we define modules by using a height cut-off for the branches\r\n\n\n#labelpred= cutree\\(hiercluster,h=heightcutoff)\r\n\n\n#cat\\(labelpred)\r\n\n\n#\"0\", grey module doesn't participate color assignment, directly assigned as \"grey\"\r\n\n\nlabelpredNoZero = labelpred\\[ labelpred >0 ]\r\n\n\nsort1=-sort\\(-table\\(labelpredNoZero))\r\n\n\nsort1\r\n\n\nmodulename= as.numeric\\(names\\(sort1))\r\n\n\nmodulebranch= sort1 >= minsize1\r\n\n\nno.modules=sum\\(modulebranch)\r\n\n\n# now we assume that there are fewer than 10 modules\r\n\n\n#colorcode=c#\\(\"turquoise\",\"blue\",\"brown\",\"yellow\",\"green\",\"red\",\"black\",\"purple\",\"orange\",\"pink\",\r\n\n\n#\"greenyellow\",\"lightcyan\",\"salmon\",\"midnightblue\",\"lightyellow\",\"chartreuse\",\r\n\n\n\"chocolate\",\"gold\",\"springgreen\",\"tan\",\"violet\",\"plum\",\"aliceblue\",\"aquamarine\",\r\n\n\n\"azure\",\"bisque\",\"burlywood\",\"coral\",\"cornsilk\",\"cyan\",\"darkorchid\",\"deeppink\",\r\n\n\n\"firebrick\",\"forestgreen\",\"gainsboro\",\"wheat\")\r\n\n\norderofcolors = order\\(runif\\(length\\(colors\\())))\r\n\n\ncolorcode = colors\\()\r\n\n\ncolorcode = colorcode\\[orderofcolors]\r\n\n\nnotgrey = substr\\(colorcode,1,4) \"gray\" | substr\\(colorcode,1,4) \"grey\"\r\n\n\ncolorcode = colorcode\\[\\!notgrey]\r\n\n\n#\"grey\" means not in any module;\r\n\n\ncolorhelp=rep\\(\"grey\",length\\(labelpred))\r\n\n\nif \\( no.modules==0)\\{\r\n\n\nprint\\(\"No module detected\\n\")\r\n\n\n}\r\n\n\nelse\\{\r\n\n\nif \\( no.modules > length\\(colorcode) )\\{\r\n\n\nprint\\(length\\(colorcode))\r\n\n\nprint\\( paste\\(\"Too many modules \\n\", as.character\\(no.modules)) )\r\n\n\n}\r\n\n\nif \\( \\(anameallmodules==FALSE) || \\(no.modules <=length\\(colorcode)) )\\{\r\n\n\nlabeledModules = min\\(no.modules, length\\(colorcode) )\r\n\n\nfor \\(i in c\\(1:labeledModules)) \\{\r\n\n\ncolorhelp=ifelse\\(labelpred==modulename\\[i],colorcode\\[i],colorhelp)\r\n\n\n}\r\n\n\ncolorhelp=factor\\(colorhelp,levels=c\\(colorcode\\[1:labeledModules],\"grey\"))\r\n\n\n}else\\{#nameallmodules==TRUE and no.modules >length\\(colorcode)\r\n\n\nmaxcolors=length\\(colorcode)\r\n\n\nlabeledModules = no.modules\r\n\n\nextracolors=NULL\r\n\n\nblackwhite=c\\(\"red\", \"black\")\r\n\n\nfor\\(i in c\\(\\(maxcolors+1):no.modules))\\{\r\n\n\nif\\(auseblackwhite==FALSE)\\{\r\n\n\nicolor=paste\\(\"module\", as.character\\(i), sep=\"\")\r\n\n\n}else\\{#use balck white alternatively represent extra colors, for display only\r\n\n\n#here we use the ordered label to avoid put the same color for two neighboring clusters\r\n\n\nicolor=blackwhite\\[1+\\(as.integer\\(modulename\\[i])%%2) ]\r\n\n\n}\r\n\n\nextracolors=c\\(extracolors, icolor)\r\n\n\n}\r\n\n\n#combine the true-color code and the extra colorcode into a uniform colorcode for\r\n\n\n#color assignment\r\n\n\nallcolorcode=c\\(colorcode, extracolors)\r\n\n\nfor \\(i in c\\(1:labeledModules)) \\{\r\n\n\ncolorhelp=ifelse\\(labelpred==modulename\\[i],allcolorcode\\[i],colorhelp)\r\n\n\n}\r\n\n\ncolorhelp=factor\\(colorhelp,levels=c\\(allcolorcode\\[1:labeledModules],\"grey\"))\r\n\n\n}\r\n\n\n}\r\n\n\ncolorhelp\r\n\n\n}\r\n\n\nhclustplot1=function\\(hier1,couleur,title1=\"Colors sorted by hierarchical clustering\") \\{\r\n\n\nif \\(length\\(hier1$order) \\!= length\\(couleur) ) \\{\r\n\n\nprint\\(\"ERROR: length of color vector not compatible with no. of objects in the hierarchical tree\")};\r\n\n\nif \\(length\\(hier1$order) == length\\(couleur) ) \\{\r\n\n\nbarplot\\(height=rep\\(1, length\\(couleur)), col= as.character\\(couleur\\[hier1$order]),border=NA, main=title1,space=0, axes=F)}\r\n\n\n}\r\n\n\nplotDend=function\\(clust,colorh)\\{\r\n\n\npar\\(mfrow=c\\(2,1),mar=c\\(2,2,2,2))\r\n\n\nplot\\(clust,labels=F)\r\n\n\nhclustplot1\\(clust,colorh)\r\n\n\n}\r\n\n\nMakeVis = function\\(data,colorMod,vis.dir,pwr1,symbols)\\{\r\n\n\nq = table\\(colorMod)\r\n\n\nn = length\\(q)\r\n\n\nfor\\(i in c\\(1:n))\\{\r\n\n\nif\\(names\\(q\\[i]) \\!= \"grey\")\\{\r\n\n\ncollect_garbage\\()\r\n\n\nnewNet = pairwiseCode\\(data\\[,colorMod==names\\(q\\[i])],filename=paste\\(vis.dir,names\\(q\\[i]),\".txt\",sep=\"\"),pwr=pwr1,geneAnnot=symbols,this.col=names\\(q\\[i]))\r\n\n\nprint\\(q\\[i])\r\n\n\nif\\(\\!exists\\(\"newNetwork\"))\\{\r\n\n\nnewNetwork = newNet\r\n\n\n} else \\{\r\n\n\nnewNetwork = rbind\\(newNetwork,newNet)\r\n\n\n}\r\n\n\n}\r\n\n\n}\r\n\n\nreturn\\(newNetwork)\r\n\n\n}\r\n\n\nMakePlots = function\\(data,colorMod,plots.dir)\\{\r\n\n\nPC = ModulePrinComps1\\(data,colorMod)\r\n\n\nq = table\\(colorMod)\r\n\n\nn = length\\(q)\r\n\n\nu = q > 1\r\n\n\nfor\\(i in c\\(1:n))\\{\r\n\n\nif\\(u\\[i])\\{\r\n\n\nc = dimnames\\(PC\\[1])\\[2]\r\n\n\nindC = substr\\(c\\[i],3,25)\r\n\n\nfilename = paste\\(plots.dir,indC,\".png\",sep=\"\")\r\n\n\npng\\(filename)\r\n\n\nshowHeat\\(indC,data,colorMod,PC)\r\n\n\ndev.off\\()\r\n\n\nprint\\(paste\\(filename,\" printed to file\"))\r\n\n\n}else\\{\r\n\n\nindC = substr\\(c\\[i],3,25)\r\n\n\nprint\\(paste\\(filename,\" only contains 1 gene\"))\r\n\n\n}\r\n\n\n}\r\n\n\n}\r\n\n\nshowHeat = function\\(color,data,colorh,PC)\\{\r\n\n\nq = table\\(colorh)\r\n\n\nz = names\\(q) == color\r\n\n\nProbe_sets = dimnames\\(data)\\[2]\r\n\n\npar\\(mfrow=c\\(2,1),mar=c\\(2,2,2,2))\r\n\n\npar\\(mar=c\\(2,3,7,3))\r\n\n\npar\\(oma=c\\(0,0,2,0))\r\n\n\ndatcombined=data.frame\\(rbind\\(data\\[,colorh==color]))\r\n\n\nsamplelabel=as.character\\(dimnames\\(data)\\[1])\r\n\n\nplot.mat\\(t\\(scale\\(datcombined)), rlabels=as.character\\(Probe_sets\\[colorh==color]), clabels=samplelabel, rcols=color)\r\n\n\npar\\(mar=c\\(2,2,0,2))\r\n\n\nbarplot\\(PC\\[1]\\[,z],space=0,beside=TRUE,axes=FALSE,col=color)\r\n\n\n}\r\n\n\nModulePrinComps1=function\\(datexpr,couleur) \\{\r\n\n\nmodlevels=levels\\(factor\\(couleur))\r\n\n\nPrinComps=data.frame\\(matrix\\(666,nrow=dim\\(datexpr)\\[1],ncol= length\\(modlevels)))\r\n\n\nvarexplained= data.frame\\(matrix\\(666,nrow= 5,ncol= length\\(modlevels)))\r\n\n\nnames\\(PrinComps)=paste\\(\"PC\",modlevels,sep=\"\")\r\n\n\nfor\\(i in c\\(1:length\\(modlevels)) )\\{\r\n\n\nprint\\(i)\r\n\n\nmodulename = modlevels\\[i]\r\n\n\nrestrict1= as.character\\(couleur)== modulename\r\n\n\n# in the following, rows are genes and columns are samples\r\n\n\ndatModule=t\\(datexpr\\[, restrict1])\r\n\n\ndatModule=impute.knn\\(as.matrix\\(datModule))\r\n\n\ndatModule=t\\(scale\\(t\\(datModule)))\r\n\n\nsvd1=svd\\(datModule)\r\n\n\nmtitle=paste\\(\"PCs of \", modulename,\" module\", sep=\"\")\r\n\n\nvarexplained\\[,i]= \\(svd1$d\\[1:5])2/sum\\(svd1$d2)\r\n\n\n# this is the first principal component\r\n\n\npc1=svd1$v\\[,1]\r\n\n\nsignh1=sign\\(sum\\(cor\\(pc1, t\\(datModule))))\r\n\n\nif \\(signh1 \\!= 0) pc1=signh1* pc1\r\n\n\nPrinComps\\[,i]= pc1\r\n\n\n}\r\n\n\nModuleConformity= rep\\(666,length=dim\\(datexpr)\\[2])\r\n\n\nfor\\(i in 1:\\(dim\\(datexpr)\\[2])) ModuleConformity\\[i]=abs\\(cor\\(datexpr\\[,i], PrinComps\\[,match\\(couleur\\[i], modlevels)], use=\"pairwise.complete.obs\"))\r\n\n\nlist\\(PrinComps=PrinComps, varexplained=varexplained, ModuleConformity=ModuleConformity)\r\n\n\n}\r\n\n\npairwiseCode = function\\(vals,filename=\"forvis.txt\",pwr,geneAnnot,links=1000,this.col)\\{\r\n\n\nn = dimnames\\(vals)\\[2]\r\n\n\nnewPC = ModulePrinComps1\\(vals,rep\\(\"black\",dim\\(vals)\\[2]))\r\n\n\nnewSim = cor\\(vals,use=\"p\")\r\n\n\nnewAdj = abs\\(newSim^pwr)\r\n\n\ndiag\\(newAdj) = 0\r\n\n\nnewDeg = apply\\(newAdj,1,sum)\r\n\n\nnewDeg = newDeg/max\\(newDeg)\r\n\n\nnewKme = cor\\(vals,newPC\\[1]\\[,1],use=\"p\")\r\n\n\nnewTom = TOMdist1\\(newAdj)\r\n\n\nnewTom = 1-newTom\r\n\n\nsz = dim\\(newAdj)\\[1]\r\n\n\nTomList = vector\\(\"logical\",sz^2)\r\n\n\nfor\\(j in c\\(1:sz))\\{\r\n\n\nTomList\\[ \\(\\(\\(j-1)**sz)+1) : \\(\\(j**sz)) ] = newTom\\[,j]\r\n\n\n}\r\n\n\nord = order\\(TomList,decreasing=TRUE)\r\n\n\nif\\(length\\(n) > 33)\\{\r\n\n\nlen = links\r\n\n\n} else \\{\r\n\n\nlen = length\\(n)^2\r\n\n\n}\r\n\n\nfirst = ord\\[1:len] %/% sz + 1\r\n\n\nsecond = ord\\[1:len] %% sz\r\n\n\nsec = second == 0\r\n\n\nfirst\\[sec] = first\\[sec]-1\r\n\n\nsecond\\[sec] = sz\r\n\n\nid = geneAnnot\\[n,2]\r\n\n\ndatout = matrix\\(0,len,6)\r\n\n\nfor\\(j in c\\(1:len))\\{\r\n\n\ndatout\\[j,1] = paste\\(id\\[first\\[j]])\r\n\n\ndatout\\[j,2] = paste\\(id\\[second\\[j]])\r\n\n\ndatout\\[j,3] = 0\r\n\n\nif\\(newSim\\[first\\[j],second\\[j]] > 0)\\{\r\n\n\ndatout\\[j,4] = as.character\\(\"M0011\")\r\n\n\n} else \\{\r\n\n\ndatout\\[j,4] = as.character\\(\"M0015\")\r\n\n\n}\r\n\n\ndatout\\[j,5] = TomList\\[ord\\[j]]\r\n\n\ndatout\\[j,6] = newSim\\[first\\[j],second\\[j]]\r\n\n\n}\r\n\n\nwrite.table\\(datout,file=filename,sep=\"\\t\")\r\n\n\nreturn\\(cbind\\(n,newDeg\\[n],as.numeric\\(newKme\\[n,1]),as.character\\(geneAnnot\\[n,2]),this.col))\r\n\n\n}\r\n\n\nmodpcas = function\\(dat,mod)\\{\r\n\n\nq = names\\(table\\(mod))\r\n\n\nu = vector\\(\"list\",length\\(q))\r\n\n\nd = vector\\(\"list\",length\\(q))\r\n\n\nv = vector\\(\"list\",length\\(q))\r\n\n\nnames\\(u) = q\r\n\n\nnames\\(d) = q\r\n\n\nnames\\(v) = q\r\n\n\nfor\\(i in c\\(1:length\\(q)))\\{\r\n\n\nb = mod == q\\[i]\r\n\n\nimpDat = impute.knn\\(as.matrix\\(dat\\[names\\(mod\\[b]),]))\r\n\n\nsclDat = t\\(scale\\(t\\(impDat)))\r\n\n\nsvdDat = svd\\(sclDat)\r\n\n\nfor\\(j in c\\(1:min\\(dim\\(dat)))\\{\r\n\n\nsignh1 = sign\\(sum\\(cor\\(svdDat$v\\[,j],t\\(sclDat))))\r\n\n\nif\\(signh1 \\!= 0)\\{\r\n\n\nsvdDat$v\\[,j]=signh1*svdDat$v\\[,j]\r\n\n\nsvdDat$u\\[,j]=signh1*svdDat$u\\[,j]\r\n\n\n}\r\n\n\nu\\[\\[i]] = svdDat$u\r\n\n\ndimnames\\(u\\[\\[i]])\\[1] = names\\(mod\\[b])\r\n\n\nd\\[\\[i]] = svdDat$d\r\n\n\nv\\[\\[i]] = svdDat$v\r\n\n\n}\r\n\n\n}\r\n\n\nreturn\\(list\\(u=u,d=d,v=v))\r\n\n\n}\r\n\n\nremovePC = function\\(pc,start)\\{\r\n\n\ndat = vector\\(\"logical\",dim\\(pc$v\\[1])\\[1])\r\n\n\nfor\\(i in c\\(1:length\\(pc$u)))\\{\r\n\n\nend = dim\\(pc$u)\\[2]\r\n\n\nD = diag\\(pc$d\\[\\[i]])\r\n\n\ne = pc$u\\[\\[i]]\\[,start:end] %**% D\\[start:end,start:end] %**% t\\(pc$v\\[\\[i]]\\[,start:end])\r\n\n\ndat = rbind\\(dat,e)\r\n\n\n}\r\n\n\nreturn\\(dat\\[2:dim\\(dat)\\[1],])\r\n\n\n}\r\n\n\n###Description of variables\r\n\n\nnormalizedData \u2013 the normalized microarray data with genes in rows and samples in columns, should also have gene identifiers for row names\r\n\n\npower_to_scale_connections \u2013 obtained with guidance from PickSoftThreshold \\(below), see Zhang et al., \\(2005) for more information\r\n\n\ngeneAnnotation \u2013 matrix with gene names in the second column and gene identifiers as row names\r\n\n\n###Create the co-expression network\r\n\n\nPickSoftThreshold\\(t\\(normalizedData))\r\n\n\npower_to_scale_connections = 6\r\n\n\ngenesClusteredOnTO = makeNetwork\\(t\\(normalizedData),power_to_scale_connections)\r\n\n\n###Identify modules and plot dendrogram\r\n\n\ngenesAssignedToModules = cutreeDynamic\\(genesClusteredOnTO)\r\n\n\nplotDend\\(genesClusteredOnTO,genesAssignedToModules)\r\n\n\n###Plot module heatmaps and make files for VisAnt\r\n\n\nMakePlots\\(normalizedData,genesAssignedToModules,\u201d./heatmaps/\u201d)\r\n\n\nNetwork = MakeVis\\(normalizedData,genesAssignedToModules,\u201d./visant/\u201d,geneAnnotation,power_to_scale_connections)\r\n\n\nwrite.table\\(Network,file=\u201dnetwork.csv\u201d,sep=\u201d,\u201d)\r\n\n\n###Remove first principal component\r\n\n\nnames\\(genesAssignedToModules) = dimnames\\(normalizedData)\\[1]\r\n\n\nprincipalComponents = modpcas\\(normalizedData,genesAssignedToModules)\r\n\n\ndataWithoutFirstPrincipalComponent = removePC\\(principalComponents,2)\r\n\n\n4. ###This code is for calculating the hypergeomtric probability of the overlap of two datasets with permutations using R\r\n  hyperFast = function\\(pop1,subpop1,pop2,subpop2,perm,b=0)\\{\r\n\n\nif\\(b==1)\\{browser\\()}\r\n\n\np1 = seq\\(1,pop1,by=1)\r\n\n\np2 = seq\\(1,pop2,by=1)\r\n\n\nout = vector\\(mode=\"logical\",perm)\r\n\n\ni = 1\r\n\n\nwhile\\(i < perm)\\{\r\n\n\nover = sample\\(p1,subpop1) %in% sample\\(p2,subpop2)\r\n\n\nif\\(length\\(table\\(over)) > 1)\\{\r\n\n\nout\\[i] = table\\(over)\\[2]\r\n\n\n} else \\{\r\n\n\nout\\[i] = 0\r\n\n\n}\r\n\n\ni = i + 1\r\n\n\n}\r\n\n\nreturn\\(out)\r\n\n\n}\r\n\n\nx=hyperFast\\(a,b,c,d,e)\r\n\n\n#a=the total number of probesets in the first gene list\r\n\n\n#b=the total number of differentially expressed genes in the first gene list\r\n\n\n#c=the total number of probesets in the second gene list\r\n\n\n#d=the total number of differentially expressed genes in the second gene list\r\n\n\n#e=the number of permutations\r\n\n\n#to calculate Z-score, use the following, where f=the number of overlapping genes in the two lists:\r\n\n\ny=\\(f-mean\\(x))/sd\\(x)\r\n\n\n#to calucate a PValue for the Z-score:\r\n\n\nz=pnorm\\(y,log=TRUE)\r\n\n\n1-\\(2^z)"
        },
        {
            "header": "References",
            "content": "Smyth, G.K., Gentleman, R., Carey, V., Dudoit, S., Irizarry, R., and Huber, W. \\(2005). Limma: linear models for microarray data. In Bioinformatics and Computational Biology Solutions using R and Bioconductor \\(Springer), pp. 397-420.\r\n\n\n\r\n\n\nGentleman, R.C., Carey, V.J., Bates, D.M., Bolstad, B., Dettling, M., Dudoit, S., Ellis, B., Gautier, L., Ge, Y., Gentry, J., et al. \\(2004). Bioconductor: open software development for computational biology and bioinformatics. Genome Biol, 5.\r\n\n\n\r\n\n\nZhang, B., and Horvath, S.  \\(2005)  A general framework for weighted gene co-expression network analysis.  Stat Appl Genet Mol Biol, 4: Article 17.\r\n\n\n\r\n\n\nLangfelder, P., Zhang, B., and Horvath, S.  \\(2008)  Defining clusters from a hierarchical cluster tree:  the Dynamic Tree Cut package for R.  Bioinformatics, 24\\(5): 719-20."
        }
    ],
    "attributes": {
        "acceptedTermsAndConditions": true,
        "allowDirectSubmit": true,
        "archivedVersions": [],
        "articleType": "Method Article",
        "associatedPublications": [
            {
                "doi": "10.1038/nature08549",
                "date": "2009-10-20 19:05:43",
                "title": "Human-specific transcriptional regulation of CNS development genes by FOXP2",
                "authors": [
                    "Genevieve Konopka",
                    "Jamee M. Bomar",
                    "Kellen Winden",
                    "Giovanni Coppola",
                    "Zophonias O. Jonsson",
                    "Fuying Gao",
                    "Sophia Peng",
                    "Todd M. Preuss",
                    "James A. Wohlschlegel & Daniel H. Geschwind"
                ],
                "journal": "Nature",
                "logo": ""
            }
        ],
        "authors": [
            {
                "id": 11321,
                "identity": "9f6cb4be-516f-11e9-9e20-12b504df345a",
                "order_by": 1,
                "name": "Giovanni Coppola",
                "email": "",
                "orcid": "",
                "institution": "UCLA",
                "correspondingAuthor": false,
                "prefix": "",
                "firstName": "Giovanni",
                "middleName": "",
                "lastName": "Coppola",
                "suffix": ""
            },
            {
                "id": 11322,
                "identity": "9f6cb8fe-516f-11e9-9e20-12b504df345a",
                "order_by": 1,
                "name": "Kellen Winden",
                "email": "",
                "orcid": "",
                "institution": "UCLA",
                "correspondingAuthor": false,
                "prefix": "",
                "firstName": "Kellen",
                "middleName": "",
                "lastName": "Winden",
                "suffix": ""
            },
            {
                "id": 11323,
                "identity": "9f6cbcaf-516f-11e9-9e20-12b504df345a",
                "order_by": 1,
                "name": "Genevieve Konopka",
                "email": "",
                "orcid": "",
                "institution": "UCLA",
                "correspondingAuthor": false,
                "prefix": "",
                "firstName": "Genevieve",
                "middleName": "",
                "lastName": "Konopka",
                "suffix": ""
            },
            {
                "id": 11324,
                "identity": "9f6cbe5d-516f-11e9-9e20-12b504df345a",
                "order_by": 1,
                "name": "Fuying Gao",
                "email": "",
                "orcid": "",
                "institution": "UCLA",
                "correspondingAuthor": false,
                "prefix": "",
                "firstName": "Fuying",
                "middleName": "",
                "lastName": "Gao",
                "suffix": ""
            },
            {
                "id": 11325,
                "identity": "9f6cbfeb-516f-11e9-9e20-12b504df345a",
                "order_by": 1,
                "name": "Daniel Geschwind",
                "email": "",
                "orcid": "",
                "institution": "UCLA",
                "correspondingAuthor": false,
                "prefix": "",
                "firstName": "Daniel",
                "middleName": "",
                "lastName": "Geschwind",
                "suffix": ""
            }
        ],
        "badges": [],
        "createdAt": "2010-09-03 14:25:09",
        "currentVersionCode": 1,
        "declarations": "",
        "doi": "10.1038/nprot.2009.215",
        "doiUrl": "https://doi.org/10.1038/nprot.2009.215",
        "draftVersion": [],
        "editorialEvents": [],
        "editorialNote": "",
        "failedWorkflow": [],
        "files": [
            {
                "id": 13464540,
                "identity": "a5de32d1-d198-4999-a1f5-4fc4b0b30aac",
                "added_by": "auto",
                "created_at": "2021-09-16 20:43:44",
                "extension": "pdf",
                "order_by": 0,
                "title": "",
                "display": "",
                "copyAsset": false,
                "role": "manuscript-pdf",
                "size": 158328,
                "visible": true,
                "origin": "",
                "legend": "",
                "description": "",
                "filename": "manuscript.pdf",
                "url": "https://assets.researchsquare.com/files/nprot-615/v1/9977dff4-39a9-4eef-9b15-595b66a0ce08.pdf"
            }
        ],
        "financialInterests": "",
        "fulltextSource": "",
        "fullText": "",
        "funders": [],
        "hasOptedInToPreprint": true,
        "hasPassedJournalQc": "",
        "hideJournal": true,
        "highlight": "",
        "institution": "",
        "isAuthorSuppliedPdf": false,
        "isDeskRejected": "",
        "isHiddenFromSearch": false,
        "isInQc": false,
        "isInWorkflow": false,
        "journal": {
            "display": true,
            "email": "protocol.exchange@nature.com",
            "identity": "protocol-exchange",
            "isNatureJournal": false,
            "hasQc": false,
            "allowDirectSubmit": true,
            "externalIdentity": "",
            "sideBox": "",
            "submissionUrl": "https://protocolexchange.researchsquare.com/submission",
            "title": "Protocol Exchange",
            "twitterHandle": ""
        },
        "keywords": "micorarrays, network analysis, functional genomics\r\n\r\n",
        "license": {
            "name": "None",
            "url": ""
        },
        "manuscriptAbstract": "",
        "manuscriptTitle": "Expression and network analysis of Illumina microarray data",
        "msid": "",
        "msnumber": "",
        "nonDraftVersions": [
            {
                "code": 1,
                "date": "2009-11-13 04:30:37",
                "doi": "10.1038/nprot.2009.215",
                "editorialEvents": [
                    {
                        "type": "communityComments",
                        "content": 0
                    }
                ],
                "status": "published",
                "journal": {
                    "display": true,
                    "email": "info@researchsquare.com",
                    "identity": "researchsquare",
                    "isNatureJournal": false,
                    "hasQc": true,
                    "allowDirectSubmit": true,
                    "externalIdentity": "",
                    "sideBox": "",
                    "submissionUrl": "/submission",
                    "title": "Research Square",
                    "twitterHandle": "researchsquare"
                }
            }
        ],
        "origin": "",
        "ownerIdentity": "9f6c3eed-516f-11e9-9e20-12b504df345a",
        "owner": [],
        "postedDate": "November 13th, 2009",
        "published": true,
        "revision": "",
        "status": "posted",
        "subjectAreas": [
            {
                "id": 2360,
                "name": "Biotechnology"
            },
            {
                "id": 2361,
                "name": "Biochemistry"
            }
        ],
        "tags": [],
        "versionOfRecord": [],
        "versionCreatedAt": "2009-11-13 04:30:37",
        "video": "",
        "vorDoi": "",
        "vorDoiUrl": "",
        "workflowStages": []
    }
}